import { 
  pgTable, serial, text, integer, timestamp, jsonb, boolean, decimal, pgEnum, varchar, numeric, index, check, sql 
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { z } from 'zod';

// ---------------- Enums ----------------
export const roleEnum = pgEnum('role', ['CONSUMER', 'MERCHANT', 'DRIVER', 'ADMIN']);
export const verificationStatusEnum = pgEnum('verification_status', ['PENDING', 'APPROVED', 'REJECTED']);
export const orderStatusEnum = pgEnum('order_status', ['PENDING', 'CONFIRMED', 'ACCEPTED', 'PICKED_UP', 'IN_TRANSIT', 'DELIVERED', 'CANCELLED']);
export const paymentStatusEnum = pgEnum('payment_status', ['PENDING', 'COMPLETED', 'FAILED', 'REFUNDED']);
export const transactionTypeEnum = pgEnum('transaction_type', ['PAYMENT', 'DELIVERY_EARNINGS', 'REFUND', 'ESCROW_RELEASE', 'TRANSFER_IN', 'TRANSFER_OUT']);
export const kycStatusEnum = pgEnum('kyc_status', ['PENDING', 'UNDER_REVIEW', 'APPROVED', 'REJECTED', 'REQUIRES_RESUBMISSION']);
export const driverTierEnum = pgEnum('driver_tier', ['STANDARD', 'PREMIUM', 'ELITE']);
export const supportStatusEnum = pgEnum('support_status', ['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED']);
export const escrowStatusEnum = pgEnum('escrow_status', ['HELD', 'RELEASED', 'REFUNDED', 'DISPUTED']);

// ---------------- Users ----------------
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: text("email").unique().notNull(),
  password: text("password"),
  fullName: text("full_name").notNull(),
  phone: text("phone"),
  profilePicture: text("profile_picture"),
  role: roleEnum("role").default('CONSUMER'),
  isVerified: boolean("is_verified").default(false),
  isActive: boolean("is_active").default(true),
  mfaEnabled: boolean("mfa_enabled").default(false),
  mfaMethod: text("mfa_method"),
  mfaSecret: text("mfa_secret"),
  mfaBackupCodes: jsonb("mfa_backup_codes").default('[]'),
  biometricHash: text("biometric_hash"),
  biometricType: text("biometric_type"),
  lastLoginAt: timestamp("last_login_at"),
  loginAttempts: integer("login_attempts").default(0),
  accountLockedUntil: timestamp("account_locked_until"),
  averageRating: numeric("average_rating", { precision: 3, scale: 2 }).default('0.00'),
  totalRatings: integer("total_ratings").default(0),
  // External payout fields for merchants/drivers (via Paystack recipients)
  paystackRecipientCode: text("paystack_recipient_code").unique(), // Unique for Paystack integration
  bankName: text("bank_name"),
  accountNumber: text("account_number"),
  accountName: text("account_name"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  emailIdx: index("users_email_idx").on(table.email),
  roleIdx: index("users_role_idx").on(table.role),
  paystackRecipientCodeIdx: index("users_paystack_recipient_idx").on(table.paystackRecipientCode)
}));

// ---------------- Categories ----------------
export const categories = pgTable("categories", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  description: text("description"),
  imageUrl: text("image_url"),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  nameIdx: index("categories_name_idx").on(table.name)
}));

// ---------------- Products ----------------
export const products = pgTable("products", {
  id: serial("id").primaryKey(),
  merchantId: integer("merchant_id").references(() => users.id), // Nullable until merchant assigned
  sellerId: integer("seller_id").references(() => users.id).notNull(),
  name: text("name").notNull(),
  description: text("description"),
  price: decimal("price", { precision: 15, scale: 2 }).notNull(),
  categoryId: integer("category_id").references(() => categories.id), // Foreign key to categories
  unit: text("unit"),
  stockQuantity: integer("stock_quantity").default(0),
  stockLevel: integer("stock_level").default(0),
  imageUrl: text("image_url"),
  images: jsonb("images").default('[]'),
  isAvailable: boolean("is_available").default(true),
  isActive: boolean("is_active").default(true),
  rating: decimal("rating", { precision: 3, scale: 2 }).default('0.00'),
  totalReviews: integer("total_reviews").default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  merchantIdIdx: index("products_merchant_id_idx").on(table.merchantId),
  sellerIdIdx: index("products_seller_id_idx").on(table.sellerId),
  categoryIdIdx: index("products_category_id_idx").on(table.categoryId),
  positivePrice: check("positive_price", sql`${table.price} > 0`)
}));

// ---------------- Orders ----------------
export const orders = pgTable("orders", {
  id: serial("id").primaryKey(),
  orderNumber: text("order_number").unique().notNull(),
  customerId: integer("customer_id").references(() => users.id).notNull(),
  merchantId: integer("merchant_id").references(() => users.id), // Nullable until merchant assigned
  driverId: integer("driver_id").references(() => users.id), // Nullable until driver assigned
  orderType: text("order_type").notNull(),
  status: orderStatusEnum("status").default('PENDING'),
  totalAmount: decimal("total_amount", { precision: 15, scale: 2 }).notNull(),
  driverEarnings: decimal("driver_earnings", { precision: 15, scale: 2 }), // Nullable until driver assigned
  deliveryAddress: text("delivery_address"),
  pickupAddress: text("pickup_address"),
  deliveryLatitude: decimal("delivery_latitude", { precision: 10, scale: 8 }),
  deliveryLongitude: decimal("delivery_longitude", { precision: 11, scale: 8 }),
  orderData: jsonb("order_data").default('{}'),
  acceptedAt: timestamp("accepted_at"),
  pickedUpAt: timestamp("picked_up_at"),
  deliveredAt: timestamp("delivered_at"),
  confirmationDeadline: timestamp("confirmation_deadline"), // For auto-release after 48h
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  customerIdIdx: index("orders_customer_id_idx").on(table.customerId),
  merchantIdIdx: index("orders_merchant_id_idx").on(table.merchantId),
  driverIdIdx: index("orders_driver_id_idx").on(table.driverId),
  orderNumberIdx: index("orders_order_number_idx").on(table.orderNumber),
  positiveTotalAmount: check("positive_total_amount", sql`${table.totalAmount} > 0`)
}));

// ---------------- Escrows ----------------
export const escrows = pgTable("escrows", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").notNull().references(() => orders.id),
  payerId: integer("payer_id").notNull().references(() => users.id), // Consumer
  payeeId: integer("payee_id").notNull().references(() => users.id), // Merchant or driver
  amount: decimal("amount", { precision: 15, scale: 2 }).notNull(),
  status: escrowStatusEnum("status").default("HELD"),
  paystackEscrowId: text("paystack_escrow_id"), // Links to Paystack transaction
  transactionRef: text("transaction_ref"), // Matches transactions.transactionRef
  createdAt: timestamp("created_at").defaultNow(),
  releasedAt: timestamp("released_at"),
  cancelledAt: timestamp("cancelled_at"),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  orderIdIdx: index("escrows_order_id_idx").on(table.orderId),
  payerIdIdx: index("escrows_payer_id_idx").on(table.payerId),
  payeeIdIdx: index("escrows_payee_id_idx").on(table.payeeId),
  positiveAmount: check("positive_amount", sql`${table.amount} > 0`)
}));

// ---------------- Transactions ----------------
export const transactions = pgTable("transactions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  orderId: integer("order_id").references(() => orders.id), // Nullable if not tied to an order
  recipientId: integer("recipient_id").references(() => users.id), // Nullable for some transaction types
  amount: decimal("amount", { precision: 15, scale: 2 }).notNull(),
  netAmount: decimal("net_amount", { precision: 15, scale: 2 }),
  currency: text("currency").default('NGN'),
  type: transactionTypeEnum("type").notNull(),
  status: paymentStatusEnum("status").default('PENDING'),
  paymentMethod: text("payment_method"),
  transactionRef: text("transaction_ref").unique(),
  paymentGatewayRef: text("payment_gateway_ref"),
  paystackTransactionId: text("paystack_transaction_id"), // Nullable until Paystack processes
  description: text("description"),
  metadata: jsonb("metadata").default('{}'),
  initiatedAt: timestamp("initiated_at"),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("transactions_user_id_idx").on(table.userId),
  orderIdIdx: index("transactions_order_id_idx").on(table.orderId),
  transactionRefIdx: index("transactions_ref_idx").on(table.transactionRef),
  paystackTransactionIdIdx: index("transactions_paystack_idx").on(table.paystackTransactionId),
  positiveAmount: check("positive_amount", sql`${table.amount} > 0`)
}));

// ---------------- Driver Profiles ----------------
export const driverProfiles = pgTable("driver_profiles", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull().unique(),
  vehicleType: varchar("vehicle_type", { length: 50 }),
  vehiclePlate: varchar("vehicle_plate", { length: 20 }),
  vehicleModel: varchar("vehicle_model", { length: 100 }),
  vehicleColor: text("vehicle_color"),
  licenseNumber: text("license_number"),
  vehicleRegistration: text("vehicle_registration"),
  currentLatitude: decimal("current_latitude", { precision: 10, scale: 8 }),
  currentLongitude: decimal("current_longitude", { precision: 11, scale: 8 }),
  isOnline: boolean("is_online").default(false),
  isAvailable: boolean("is_available").default(true),
  currentLocation: text("current_location"),
  rating: decimal("rating", { precision: 3, scale: 2 }).default('0.00'),
  totalRatings: integer("total_ratings").default(0),
  totalDeliveries: integer("total_deliveries").default(0),
  totalEarnings: decimal("total_earnings", { precision: 15, scale: 2 }).default('0.00'),
  averageDeliveryTime: integer("average_delivery_time"),
  verificationStatus: verificationStatusEnum("verification_status").default('PENDING'),
  tier: driverTierEnum("tier").default('STANDARD'),
  kycData: jsonb("kyc_data").default('{}'),
  kycStatus: kycStatusEnum("kyc_status").default('PENDING'),
  kycSubmittedAt: timestamp("kyc_submitted_at"),
  kycApprovedAt: timestamp("kyc_approved_at"),
  kycApprovedBy: integer("kyc_approved_by").references(() => users.id),
  verificationLevel: text("verification_level").default('BASIC'),
  backgroundCheckStatus: text("background_check_status").default('PENDING'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("driver_profiles_user_id_idx").on(table.userId),
  positiveEarnings: check("positive_earnings", sql`${table.totalEarnings} >= 0`)
}));

// ---------------- Merchant Profiles ----------------
export const merchantProfiles = pgTable("merchant_profiles", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull().unique(),
  businessName: text("business_name").notNull(),
  businessAddress: text("business_address"),
  businessType: text("business_type"),
  businessPhone: text("business_phone"),
  businessEmail: text("business_email"),
  latitude: decimal("latitude", { precision: 10, scale: 8 }),
  longitude: decimal("longitude", { precision: 11, scale: 8 }),
  phone: text("phone"),
  description: text("description"),
  operatingHours: jsonb("operating_hours").default('{}'),
  isOpen: boolean("is_open").default(true),
  isVerified: boolean("is_verified").default(false),
  isActive: boolean("is_active").default(true),
  rating: decimal("rating", { precision: 3, scale: 2 }).default('0.00'),
  totalOrders: integer("total_orders").default(0),
  revenue: decimal("revenue", { precision: 15, scale: 2 }).default('0.00'),
  verificationStatus: verificationStatusEnum("verification_status").default('PENDING'),
  kycData: jsonb("kyc_data").default('{}'),
  kycStatus: kycStatusEnum("kyc_status").default('PENDING'),
  kycSubmittedAt: timestamp("kyc_submitted_at"),
  kycApprovedAt: timestamp("kyc_approved_at"),
  kycApprovedBy: integer("kyc_approved_by").references(() => users.id),
  verificationLevel: text("verification_level").default('BASIC'),
  backgroundCheckStatus: text("background_check_status").default('PENDING'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("merchant_profiles_user_id_idx").on(table.userId),
  positiveRevenue: check("positive_revenue", sql`${table.revenue} >= 0`)
}));

// ---------------- Fuel Orders ----------------
export const fuelOrders = pgTable("fuel_orders", {
  id: serial("id").primaryKey(),
  customerId: integer("customer_id").references(() => users.id).notNull(),
  driverId: integer("driver_id").references(() => users.id), // Nullable until driver assigned
  stationId: text("station_id").notNull(),
  fuelType: text("fuel_type").notNull(),
  quantity: decimal("quantity", { precision: 10, scale: 2 }).notNull(),
  unitPrice: decimal("unit_price", { precision: 15, scale: 2 }).notNull(),
  totalAmount: decimal("total_amount", { precision: 15, scale: 2 }).notNull(),
  deliveryAddress: text("delivery_address").notNull(),
  deliveryLatitude: decimal("delivery_latitude", { precision: 10, scale: 8 }),
  deliveryLongitude: decimal("delivery_longitude", { precision: 11, scale: 8 }),
  status: orderStatusEnum("status").default('PENDING'),
  scheduledDeliveryTime: text("scheduled_delivery_time"),
  acceptedAt: timestamp("accepted_at"),
  pickedUpAt: timestamp("picked_up_at"),
  deliveredAt: timestamp("delivered_at"),
  estimatedDeliveryTime: text("estimated_delivery_time"),
  notes: text("notes"),
  confirmationDeadline: timestamp("confirmation_deadline"), // For auto-release after 48h
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  customerIdIdx: index("fuel_orders_customer_id_idx").on(table.customerId),
  driverIdIdx: index("fuel_orders_driver_id_idx").on(table.driverId),
  positiveQuantity: check("positive_quantity", sql`${table.quantity} > 0`),
  positiveUnitPrice: check("positive_unit_price", sql`${table.unitPrice} > 0`),
  positiveTotalAmount: check("positive_total_amount", sql`${table.totalAmount} > 0`)
}));

// ---------------- Ratings ----------------
export const ratings = pgTable("ratings", {
  id: serial("id").primaryKey(),
  customerId: integer("customer_id").references(() => users.id), // Nullable if anonymous rating allowed
  orderId: integer("order_id").references(() => orders.id),
  driverId: integer("driver_id").references(() => users.id),
  merchantId: integer("merchant_id").references(() => users.id),
  productId: integer("product_id").references(() => products.id),
  rating: integer("rating").notNull(),
  comment: text("comment"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  customerIdIdx: index("ratings_customer_id_idx").on(table.customerId),
  orderIdIdx: index("ratings_order_id_idx").on(table.orderId),
  driverIdIdx: index("ratings_driver_id_idx").on(table.driverId),
  merchantIdIdx: index("ratings_merchant_id_idx").on(table.merchantId),
  productIdIdx: index("ratings_product_id_idx").on(table.productId),
  validRating: check("valid_rating", sql`${table.rating} >= 1 AND ${table.rating} <= 5`)
}));

// ---------------- Delivery Feedback ----------------
export const deliveryFeedback = pgTable("delivery_feedback", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => orders.id).notNull(),
  customerId: integer("customer_id").references(() => users.id).notNull(),
  driverId: integer("driver_id").references(() => users.id).notNull(),
  feedbackType: varchar("feedback_type", { length: 50 }).notNull(),
  driverRating: integer("driver_rating"),
  serviceRating: integer("service_rating"),
  deliveryTimeRating: integer("delivery_time_rating"),
  deliveryQuality: varchar("delivery_quality", { length: 20 }),
  wouldRecommend: boolean("would_recommend"),
  issuesReported: text("issues_reported"),
  customerRating: integer("customer_rating"),
  deliveryComplexity: varchar("delivery_complexity", { length: 20 }),
  customerCooperation: varchar("customer_cooperation", { length: 20 }),
  paymentIssues: boolean("payment_issues"),
  comment: text("comment"),
  additionalFeedback: text("additional_feedback"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  orderIdIdx: index("delivery_feedback_order_id_idx").on(table.orderId),
  customerIdIdx: index("delivery_feedback_customer_id_idx").on(table.customerId),
  driverIdIdx: index("delivery_feedback_driver_id_idx").on(table.driverId),
  validDriverRating: check("valid_driver_rating", sql`${table.driverRating} IS NULL OR (${table.driverRating} >= 1 AND ${table.driverRating} <= 5)`),
  validServiceRating: check("valid_service_rating", sql`${table.serviceRating} IS NULL OR (${table.serviceRating} >= 1 AND ${table.serviceRating} <= 5)`),
  validDeliveryTimeRating: check("valid_delivery_time_rating", sql`${table.deliveryTimeRating} IS NULL OR (${table.deliveryTimeRating} >= 1 AND ${table.deliveryTimeRating} <= 5)`),
  validCustomerRating: check("valid_customer_rating", sql`${table.customerRating} IS NULL OR (${table.customerRating} >= 1 AND ${table.customerRating} <= 5)`)
}));

// ---------------- Delivery Confirmations ----------------
export const deliveryConfirmations = pgTable("delivery_confirmations", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => orders.id).notNull().unique(),
  driverConfirmed: boolean("driver_confirmed").default(false),
  consumerConfirmed: boolean("consumer_confirmed").default(false),
  confirmationDeadline: timestamp("confirmation_deadline"), // For auto-release
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  orderIdIdx: index("delivery_confirmations_order_id_idx").on(table.orderId)
}));

// ---------------- Support Tickets ----------------
export const supportTickets = pgTable("support_tickets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  ticketNumber: text("ticket_number").unique().notNull(),
  title: text("title").notNull(),
  description: text("description").notNull(),
  category: text("category").notNull(),
  priority: text("priority").default('MEDIUM'),
  status: supportStatusEnum("status").default('OPEN'),
  assignedTo: integer("assigned_to").references(() => users.id), // Nullable until assigned
  attachments: jsonb("attachments").default('[]'),
  metadata: jsonb("metadata").default('{}'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  resolvedAt: timestamp("resolved_at"),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("support_tickets_user_id_idx").on(table.userId),
  ticketNumberIdx: index("support_tickets_ticket_number_idx").on(table.ticketNumber)
}));

// ---------------- Audit Logs ----------------
export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id), // Nullable for system actions
  action: text("action").notNull(), // e.g., 'LOGIN', 'ORDER_CREATED', 'PAYMENT_PROCESSED'
  entityType: text("entity_type"), // e.g., 'USER', 'ORDER', 'TRANSACTION'
  entityId: integer("entity_id"),
  details: jsonb("details").default('{}'),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  createdAt: timestamp("created_at").defaultNow()
}, (table) => ({
  userIdIdx: index("audit_logs_user_id_idx").on(table.userId),
  entityTypeIdx: index("audit_logs_entity_type_idx").on(table.entityType)
}));

// ---------------- Tracking ----------------
export const tracking = pgTable("tracking", {
  id: serial("id").primaryKey(),
  orderId: integer("order_id").references(() => orders.id).notNull(),
  driverId: integer("driver_id").references(() => users.id), // Nullable if no driver yet
  latitude: decimal("latitude", { precision: 10, scale: 8 }),
  longitude: decimal("longitude", { precision: 11, scale: 8 }),
  status: text("status"), // e.g., 'EN_ROUTE', 'AT_PICKUP', 'AT_DELIVERY'
  timestamp: timestamp("timestamp").defaultNow(),
  createdAt: timestamp("created_at").defaultNow()
}, (table) => ({
  orderIdIdx: index("tracking_order_id_idx").on(table.orderId),
  driverIdIdx: index("tracking_driver_id_idx").on(table.driverId)
}));

// ---------------- Fraud Alerts ----------------
export const fraudAlerts = pgTable("fraud_alerts", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  transactionId: integer("transaction_id").references(() => transactions.id),
  orderId: integer("order_id").references(() => orders.id),
  reason: text("reason").notNull(),
  severity: text("severity").default('MEDIUM'), // 'LOW', 'MEDIUM', 'HIGH'
  status: text("status").default('PENDING'), // 'PENDING', 'INVESTIGATED', 'RESOLVED'
  metadata: jsonb("metadata").default('{}'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("fraud_alerts_user_id_idx").on(table.userId),
  transactionIdIdx: index("fraud_alerts_transaction_id_idx").on(table.transactionId),
  orderIdIdx: index("fraud_alerts_order_id_idx").on(table.orderId)
}));

// ---------------- Messages (Chat) ----------------
export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: integer("sender_id").references(() => users.id).notNull(),
  receiverId: integer("receiver_id").references(() => users.id).notNull(),
  orderId: integer("order_id").references(() => orders.id), // Nullable for non-order-related chats
  supportTicketId: integer("support_ticket_id").references(() => supportTickets.id), // Nullable for non-ticket chats
  message: text("message").notNull(),
  isRead: boolean("is_read").default(false),
  metadata: jsonb("metadata").default('{}'),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  senderIdIdx: index("messages_sender_id_idx").on(table.senderId),
  receiverIdIdx: index("messages_receiver_id_idx").on(table.receiverId),
  orderIdIdx: index("messages_order_id_idx").on(table.orderId),
  supportTicketIdIdx: index("messages_support_ticket_id_idx").on(table.supportTicketId)
}));

// ---------------- Notifications ----------------
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  title: text("title").notNull(),
  message: text("message").notNull(),
  type: text("type").notNull(),
  isRead: boolean("is_read").default(false),
  metadata: jsonb("metadata").default('{}'),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("notifications_user_id_idx").on(table.userId)
}));

// ---------------- Identity Verifications ----------------
export const identityVerifications = pgTable("identity_verifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  documentType: text("document_type").notNull(),
  documentNumber: text("document_number").notNull(),
  documentImageUrl: text("document_image_url"),
  verificationStatus: verificationStatusEnum("verification_status").default('PENDING'),
  submittedAt: timestamp("submitted_at").defaultNow(),
  reviewedAt: timestamp("reviewed_at"),
  reviewedBy: integer("reviewed_by").references(() => users.id),
  rejectionReason: text("rejection_reason"),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("identity_verifications_user_id_idx").on(table.userId)
}));

// ---------------- Error Logs ----------------
export const errorLogs = pgTable("error_logs", {
  id: serial("id").primaryKey(),
  message: text("message").notNull(),
  stack: text("stack"),
  url: text("url"),
  userAgent: text("user_agent"),
  userId: integer("user_id").references(() => users.id),
  severity: text("severity").default("MEDIUM"),
  source: text("source").default("backend"),
  timestamp: timestamp("timestamp").defaultNow(),
  metadata: jsonb("metadata").default('{}'),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("error_logs_user_id_idx").on(table.userId)
}));

// ---------------- MFA Tokens ----------------
export const mfaTokens = pgTable("mfa_tokens", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  token: text("token").notNull(),
  method: text("method").notNull(),
  expiresAt: timestamp("expires_at").notNull(),
  isUsed: boolean("is_used").default(false),
  usedAt: timestamp("used_at"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("mfa_tokens_user_id_idx").on(table.userId)
}));

// ---------------- Verification Documents ----------------
export const verificationDocuments = pgTable("verification_documents", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  documentType: text("document_type").notNull(),
  documentNumber: text("document_number"),
  fileName: text("file_name").notNull(),
  fileSize: integer("file_size"),
  mimeType: text("mime_type"),
  expiryDate: timestamp("expiry_date"),
  status: text("status").default('PENDING'),
  validationScore: decimal("validation_score", { precision: 3, scale: 2 }),
  extractedData: jsonb("extracted_data").default('{}'),
  rejectionReason: text("rejection_reason"),
  reviewedBy: integer("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  uploadedAt: timestamp("uploaded_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("verification_documents_user_id_idx").on(table.userId)
}));

// ---------------- Security Logs ----------------
export const securityLogs = pgTable("security_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  action: text("action").notNull(),
  details: jsonb("details").default('{}'),
  ipAddress: text("ip_address"),
  userAgent: text("user_agent"),
  severity: text("severity").default('INFO'),
  timestamp: timestamp("timestamp").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("security_logs_user_id_idx").on(table.userId)
}));

// ---------------- Trusted Devices ----------------
export const trustedDevices = pgTable("trusted_devices", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  deviceToken: text("device_token").unique().notNull(),
  deviceName: text("device_name"),
  deviceType: text("device_type"),
  browserInfo: text("browser_info"),
  lastUsedAt: timestamp("last_used_at"),
  expiresAt: timestamp("expires_at").notNull(),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("trusted_devices_user_id_idx").on(table.userId),
  deviceTokenIdx: index("trusted_devices_device_token_idx").on(table.deviceToken)
}));

// ---------------- Toll Gates ----------------
export const tollGates = pgTable("toll_gates", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  location: text("location").notNull(),
  latitude: decimal("latitude", { precision: 10, scale: 8 }).notNull(),
  longitude: decimal("longitude", { precision: 11, scale: 8 }).notNull(),
  price: decimal("price", { precision: 15, scale: 2 }).notNull(),
  operatingHours: jsonb("operating_hours").default('{}'),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  nameIdx: index("toll_gates_name_idx").on(table.name),
  positivePrice: check("positive_price", sql`${table.price} > 0`)
}));

// ---------------- Suspicious Activities ----------------
export const suspiciousActivities = pgTable("suspicious_activities", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id),
  activityType: text("activity_type").notNull(),
  description: text("description").notNull(),
  riskIndicators: jsonb("risk_indicators").default('{}'),
  timestamp: timestamp("timestamp").defaultNow(),
  ipAddress: text("ip_address"),
  deviceFingerprint: text("device_fingerprint"),
  severity: text("severity").default('MEDIUM'),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("suspicious_activities_user_id_idx").on(table.userId)
}));

// ---------------- Admin Users ----------------
export const adminUsers = pgTable("admin_users", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  role: text("role").default('ADMIN'),
  permissions: jsonb("permissions").default('[]'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("admin_users_user_id_idx").on(table.userId)
}));

// ---------------- Compliance Documents ----------------
export const complianceDocuments = pgTable("compliance_documents", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  documentType: text("document_type").notNull(),
  documentUrl: text("document_url").notNull(),
  status: text("status").default('PENDING'),
  reviewedBy: integer("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("compliance_documents_user_id_idx").on(table.userId)
}));

// ---------------- Content Reports ----------------
export const contentReports = pgTable("content_reports", {
  id: serial("id").primaryKey(),
  contentType: text("content_type").notNull(),
  contentId: text("content_id").notNull(),
  reportedBy: integer("reported_by").references(() => users.id),
  reason: text("reason").notNull(),
  status: text("status").default('PENDING'),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  reportedByIdx: index("content_reports_reported_by_idx").on(table.reportedBy)
}));

// ---------------- Moderation Responses ----------------
export const moderationResponses = pgTable("moderation_responses", {
  id: serial("id").primaryKey(),
  reportId: integer("report_id").references(() => contentReports.id).notNull(),
  adminId: integer("admin_id").references(() => adminUsers.id).notNull(),
  response: text("response").notNull(),
  action: text("action").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  reportIdIdx: index("moderation_responses_report_id_idx").on(table.reportId),
  adminIdIdx: index("moderation_responses_admin_id_idx").on(table.adminId)
}));

// ---------------- User Locations ----------------
export const userLocations = pgTable("user_locations", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  latitude: decimal("latitude", { precision: 10, scale: 8 }).notNull(),
  longitude: decimal("longitude", { precision: 11, scale: 8 }).notNull(),
  heading: decimal("heading", { precision: 5, scale: 2 }),
  speed: decimal("speed", { precision: 8, scale: 2 }),
  accuracy: decimal("accuracy", { precision: 8, scale: 2 }),
  locationType: text("location_type"),
  timestamp: timestamp("timestamp").defaultNow(),
  isActive: boolean("is_active").default(true),
  updatedAt: timestamp("updated_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("user_locations_user_id_idx").on(table.userId)
}));

// ---------------- Payment Methods ----------------
export const paymentMethods = pgTable("payment_methods", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  type: text("type").notNull(),
  details: jsonb("details").notNull(),
  isDefault: boolean("is_default").default(false),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("payment_methods_user_id_idx").on(table.userId)
}));

// ---------------- Admin Payment Actions ----------------
export const adminPaymentActions = pgTable("admin_payment_actions", {
  id: serial("id").primaryKey(),
  adminId: integer("admin_id").references(() => adminUsers.id).notNull(),
  action: text("action").notNull(),
  paymentId: text("payment_id").notNull(),
  details: jsonb("details").default('{}'),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  adminIdIdx: index("admin_payment_actions_admin_id_idx").on(table.adminId)
}));

// ---------------- Account Flags ----------------
export const accountFlags = pgTable("account_flags", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  flagType: text("flag_type").notNull(),
  severity: text("severity").default('MEDIUM'),
  reason: text("reason").notNull(),
  flaggedBy: integer("flagged_by").references(() => adminUsers.id),
  status: text("status").default('ACTIVE'),
  resolvedBy: integer("resolved_by").references(() => adminUsers.id),
  resolvedAt: timestamp("resolved_at"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("account_flags_user_id_idx").on(table.userId)
}));

// ---------------- Conversations ----------------
export const conversations = pgTable("conversations", {
  id: serial("id").primaryKey(),
  customerId: integer("customer_id").references(() => users.id).notNull(),
  status: text("status").default('ACTIVE'),
  lastMessage: text("last_message"),
  lastMessageAt: timestamp("last_message_at"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  customerIdIdx: index("conversations_customer_id_idx").on(table.customerId)
}));

// ---------------- Driver Verifications ----------------
export const driverVerifications = pgTable("driver_verifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  documentType: text("document_type").notNull(),
  documentUrl: text("document_url").notNull(),
  status: verificationStatusEnum("status").default('PENDING'),
  reviewedBy: integer("reviewed_by").references(() => users.id),
  reviewedAt: timestamp("reviewed_at"),
  createdAt: timestamp("created_at").defaultNow(),
  deletedAt: timestamp("deleted_at") // Soft delete
}, (table) => ({
  userIdIdx: index("driver_verifications_user_id_idx").on(table.userId)
}));

// ---------------- Relations ----------------
export const usersRelations = relations(users, ({ many, one }) => ({
  ordersAsCustomer: many(orders, { relationName: "customer" }),
  ordersAsMerchant: many(orders, { relationName: "merchant" }),
  ordersAsDriver: many(orders, { relationName: "driver" }),
  driverProfile: one(driverProfiles, {
    fields: [users.id],
    references: [driverProfiles.userId]
  }),
  merchantProfile: one(merchantProfiles, {
    fields: [users.id],
    references: [merchantProfiles.userId]
  }),
  transactions: many(transactions),
  supportTickets: many(supportTickets),
  ratings: many(ratings),
  deliveryFeedback: many(deliveryFeedback),
  messagesSent: many(messages, { relationName: "sender" }),
  messagesReceived: many(messages, { relationName: "receiver" }),
  auditLogs: many(auditLogs),
  fraudAlerts: many(fraudAlerts),
  notifications: many(notifications),
  identityVerifications: many(identityVerifications),
  errorLogs: many(errorLogs),
  mfaTokens: many(mfaTokens),
  verificationDocuments: many(verificationDocuments),
  securityLogs: many(securityLogs),
  trustedDevices: many(trustedDevices),
  suspiciousActivities: many(suspiciousActivities),
  complianceDocuments: many(complianceDocuments),
  contentReports: many(contentReports),
  userLocations: many(userLocations),
  paymentMethods: many(paymentMethods),
  accountFlags: many(accountFlags),
  conversations: many(conversations),
  driverVerifications: many(driverVerifications)
}));

export const categoriesRelations = relations(categories, ({ many }) => ({
  products: many(products)
}));

export const productsRelations = relations(products, ({ one, many }) => ({
  merchant: one(users, {
    fields: [products.merchantId],
    references: [users.id]
  }),
  seller: one(users, {
    fields: [products.sellerId],
    references: [users.id]
  }),
  category: one(categories, {
    fields: [products.categoryId],
    references: [categories.id]
  }),
  ratings: many(ratings)
}));

export const ordersRelations = relations(orders, ({ one, many }) => ({
  customer: one(users, {
    fields: [orders.customerId],
    references: [users.id],
    relationName: "customer"
  }),
  merchant: one(users, {
    fields: [orders.merchantId],
    references: [users.id],
    relationName: "merchant"
  }),
  driver: one(users, {
    fields: [orders.driverId],
    references: [users.id],
    relationName: "driver"
  }),
  escrows: many(escrows),
  transactions: many(transactions),
  ratings: many(ratings),
  deliveryFeedback: many(deliveryFeedback),
  tracking: many(tracking),
  messages: many(messages),
  fraudAlerts: many(fraudAlerts),
  deliveryConfirmation: one(deliveryConfirmations, {
    fields: [orders.id],
    references: [deliveryConfirmations.orderId]
  })
}));

export const escrowsRelations = relations(escrows, ({ one }) => ({
  order: one(orders, {
    fields: [escrows.orderId],
    references: [orders.id]
  }),
  payer: one(users, {
    fields: [escrows.payerId],
    references: [users.id]
  }),
  payee: one(users, {
    fields: [escrows.payeeId],
    references: [users.id]
  })
}));

export const transactionsRelations = relations(transactions, ({ one, many }) => ({
  user: one(users, {
    fields: [transactions.userId],
    references: [users.id]
  }),
  order: one(orders, {
    fields: [transactions.orderId],
    references: [orders.id]
  }),
  recipient: one(users, {
    fields: [transactions.recipientId],
    references: [users.id]
  }),
  fraudAlerts: many(fraudAlerts)
}));

export const driverProfilesRelations = relations(driverProfiles, ({ one }) => ({
  user: one(users, {
    fields: [driverProfiles.userId],
    references: [users.id]
  }),
  kycApprovedBy: one(users, {
    fields: [driverProfiles.kycApprovedBy],
    references: [users.id]
  })
}));

export const merchantProfilesRelations = relations(merchantProfiles, ({ one }) => ({
  user: one(users, {
    fields: [merchantProfiles.userId],
    references: [users.id]
  }),
  kycApprovedBy: one(users, {
    fields: [merchantProfiles.kycApprovedBy],
    references: [users.id]
  })
}));

export const fuelOrdersRelations = relations(fuelOrders, ({ one }) => ({
  customer: one(users, {
    fields: [fuelOrders.customerId],
    references: [users.id]
  }),
  driver: one(users, {
    fields: [fuelOrders.driverId],
    references: [users.id]
  })
}));

export const ratingsRelations = relations(ratings, ({ one }) => ({
  customer: one(users, {
    fields: [ratings.customerId],
    references: [users.id]
  }),
  order: one(orders, {
    fields: [ratings.orderId],
    references: [orders.id]
  }),
  driver: one(users, {
    fields: [ratings.driverId],
    references: [users.id]
  }),
  merchant: one(users, {
    fields: [ratings.merchantId],
    references: [users.id]
  }),
  product: one(products, {
    fields: [ratings.productId],
    references: [products.id]
  })
}));

export const deliveryFeedbackRelations = relations(deliveryFeedback, ({ one }) => ({
  order: one(orders, {
    fields: [deliveryFeedback.orderId],
    references: [orders.id]
  }),
  customer: one(users, {
    fields: [deliveryFeedback.customerId],
    references: [users.id]
  }),
  driver: one(users, {
    fields: [deliveryFeedback.driverId],
    references: [users.id]
  })
}));

export const deliveryConfirmationsRelations = relations(deliveryConfirmations, ({ one }) => ({
  order: one(orders, {
    fields: [deliveryConfirmations.orderId],
    references: [orders.id]
  })
}));

export const supportTicketsRelations = relations(supportTickets, ({ one, many }) => ({
  user: one(users, {
    fields: [supportTickets.userId],
    references: [users.id]
  }),
  assignedTo: one(users, {
    fields: [supportTickets.assignedTo],
    references: [users.id]
  }),
  messages: many(messages)
}));

export const auditLogsRelations = relations(auditLogs, ({ one }) => ({
  user: one(users, {
    fields: [auditLogs.userId],
    references: [users.id]
  })
}));

export const trackingRelations = relations(tracking, ({ one }) => ({
  order: one(orders, {
    fields: [tracking.orderId],
    references: [orders.id]
  }),
  driver: one(users, {
    fields: [tracking.driverId],
    references: [users.id]
  })
}));

export const fraudAlertsRelations = relations(fraudAlerts, ({ one }) => ({
  user: one(users, {
    fields: [fraudAlerts.userId],
    references: [users.id]
  }),
  transaction: one(transactions, {
    fields: [fraudAlerts.transactionId],
    references: [transactions.id]
  }),
  order: one(orders, {
    fields: [fraudAlerts.orderId],
    references: [orders.id]
  })
}));

export const messagesRelations = relations(messages, ({ one }) => ({
  sender: one(users, {
    fields: [messages.senderId],
    references: [users.id],
    relationName: "sender"
  }),
  receiver: one(users, {
    fields: [messages.receiverId],
    references: [users.id],
    relationName: "receiver"
  }),
  order: one(orders, {
    fields: [messages.orderId],
    references: [orders.id]
  }),
  supportTicket: one(supportTickets, {
    fields: [messages.supportTicketId],
    references: [supportTickets.id]
  })
}));

export const notificationsRelations = relations(notifications, ({ one }) => ({
  user: one(users, {
    fields: [notifications.userId],
    references: [users.id]
  })
}));

export const identityVerificationsRelations = relations(identityVerifications, ({ one }) => ({
  user: one(users, {
    fields: [identityVerifications.userId],
    references: [users.id]
  }),
  reviewedBy: one(users, {
    fields: [identityVerifications.reviewedBy],
    references: [users.id]
  })
}));

export const errorLogsRelations = relations(errorLogs, ({ one }) => ({
  user: one(users, {
    fields: [errorLogs.userId],
    references: [users.id]
  })
}));

export const mfaTokensRelations = relations(mfaTokens, ({ one }) => ({
  user: one(users, {
    fields: [mfaTokens.userId],
    references: [users.id]
  })
}));

export const verificationDocumentsRelations = relations(verificationDocuments, ({ one }) => ({
  user: one(users, {
    fields: [verificationDocuments.userId],
    references: [users.id]
  }),
  reviewedBy: one(users, {
    fields: [verificationDocuments.reviewedBy],
    references: [users.id]
  })
}));

export const securityLogsRelations = relations(securityLogs, ({ one }) => ({
  user: one(users, {
    fields: [securityLogs.userId],
    references: [users.id]
  })
}));

export const trustedDevicesRelations = relations(trustedDevices, ({ one }) => ({
  user: one(users, {
    fields: [trustedDevices.userId],
    references: [users.id]
  })
}));

export const suspiciousActivitiesRelations = relations(suspiciousActivities, ({ one }) => ({
  user: one(users, {
    fields: [suspiciousActivities.userId],
    references: [users.id]
  })
}));

export const adminUsersRelations = relations(adminUsers, ({ one }) => ({
  user: one(users, {
    fields: [adminUsers.userId],
    references: [users.id]
  })
}));

export const complianceDocumentsRelations = relations(complianceDocuments, ({ one }) => ({
  user: one(users, {
    fields: [complianceDocuments.userId],
    references: [users.id]
  }),
  reviewedBy: one(users, {
    fields: [complianceDocuments.reviewedBy],
    references: [users.id]
  })
}));

export const contentReportsRelations = relations(contentReports, ({ one, many }) => ({
  reportedBy: one(users, {
    fields: [contentReports.reportedBy],
    references: [users.id]
  }),
  moderationResponses: many(moderationResponses)
}));

export const moderationResponsesRelations = relations(moderationResponses, ({ one }) => ({
  report: one(contentReports, {
    fields: [moderationResponses.reportId],
    references: [contentReports.id]
  }),
  admin: one(adminUsers, {
    fields: [moderationResponses.adminId],
    references: [adminUsers.id]
  })
}));

export const userLocationsRelations = relations(userLocations, ({ one }) => ({
  user: one(users, {
    fields: [userLocations.userId],
    references: [users.id]
  })
}));

export const paymentMethodsRelations = relations(paymentMethods, ({ one }) => ({
  user: one(users, {
    fields: [paymentMethods.userId],
    references: [users.id]
  })
}));

export const adminPaymentActionsRelations = relations(adminPaymentActions, ({ one }) => ({
  admin: one(adminUsers, {
    fields: [adminPaymentActions.adminId],
    references: [adminUsers.id]
  })
}));

export const accountFlagsRelations = relations(accountFlags, ({ one }) => ({
  user: one(users, {
    fields: [accountFlags.userId],
    references: [users.id]
  }),
  flaggedBy: one(adminUsers, {
    fields: [accountFlags.flaggedBy],
    references: [adminUsers.id]
  }),
  resolvedBy: one(adminUsers, {
    fields: [accountFlags.resolvedBy],
    references: [adminUsers.id]
  })
}));

export const conversationsRelations = relations(conversations, ({ one }) => ({
  customer: one(users, {
    fields: [conversations.customerId],
    references: [users.id]
  })
}));

export const driverVerificationsRelations = relations(driverVerifications, ({ one }) => ({
  user: one(users, {
    fields: [driverVerifications.userId],
    references: [users.id]
  }),
  reviewedBy: one(users, {
    fields: [driverVerifications.reviewedBy],
    references: [users.id]
  })
}));

// ---------------- Validation Schemas ----------------
export const insertUserSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
  fullName: z.string().min(1),
  phone: z.string().optional(),
  role: z.enum(['CONSUMER', 'MERCHANT', 'DRIVER', 'ADMIN']).default('CONSUMER')
});

export const insertProductSchema = z.object({
  merchantId: z.number(),
  name: z.string().min(1),
  description: z.string().optional(),
  price: z.number().positive(),
  categoryId: z.number(),
  unit: z.string().min(1),
  stockQuantity: z.number().min(0).default(0),
  imageUrl: z.string().url().optional()
});

export const insertOrderSchema = z.object({
  customerId: z.number(),
  merchantId: z.number().optional(),
  orderType: z.string(),
  totalAmount: z.number().positive(),
  deliveryAddress: z.string().min(1),
  orderData: z.any().optional()
});

export const insertFuelOrderSchema = z.object({
  customerId: z.number(),
  stationId: z.string(),
  fuelType: z.enum(['PMS', 'AGO', 'DPK']),
  quantity: z.number().positive(),
  unitPrice: z.number().positive(),
  totalAmount: z.number().positive(),
  deliveryAddress: z.string().min(1),
  deliveryLatitude: z.number().optional(),
  deliveryLongitude: z.number().optional(),
  scheduledDeliveryTime: z.string().optional()
});

export const insertTransactionSchema = z.object({
  userId: z.number(),
  amount: z.number().positive(),
  type: z.enum(['PAYMENT', 'DELIVERY_EARNINGS', 'REFUND', 'ESCROW_RELEASE', 'TRANSFER_IN', 'TRANSFER_OUT']),
  paymentMethod: z.string(),
  description: z.string().optional()
});

export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Product = typeof products.$inferSelect;
export type NewProduct = typeof products.$inferInsert;
export type Order = typeof orders.$inferSelect;
export type NewOrder = typeof orders.$inferInsert;
export type Transaction = typeof transactions.$inferSelect;
export type NewTransaction = typeof transactions.$inferInsert;
export type DriverProfile = typeof driverProfiles.$inferSelect;
export type NewDriverProfile = typeof driverProfiles.$inferInsert;
export type MerchantProfile = typeof merchantProfiles.$inferSelect;
export type NewMerchantProfile = typeof merchantProfiles.$inferInsert;
export type FuelOrder = typeof fuelOrders.$inferSelect;
export type NewFuelOrder = typeof fuelOrders.$inferInsert;
export type Rating = typeof ratings.$inferSelect;
export type NewRating = typeof ratings.$inferInsert;
export type DeliveryFeedback = typeof deliveryFeedback.$inferSelect;
export type NewDeliveryFeedback = typeof deliveryFeedback.$inferInsert;
export type SupportTicket = typeof supportTickets.$inferSelect;
export type NewSupportTicket = typeof supportTickets.$inferInsert;
export type Message = typeof messages.$inferSelect;
export type NewMessage = typeof messages.$inferInsert;
export type Notification = typeof notifications.$inferSelect;
export type NewNotification = typeof notifications.$inferInsert;
export type IdentityVerification = typeof identityVerifications.$inferSelect;
export type NewIdentityVerification = typeof identityVerifications.$inferInsert;
export type ErrorLog = typeof errorLogs.$inferSelect;
export type NewErrorLog = typeof errorLogs.$inferInsert;
export type MfaToken = typeof mfaTokens.$inferSelect;
export type NewMfaToken = typeof mfaTokens.$inferInsert;
export type VerificationDocument = typeof verificationDocuments.$inferSelect;
export type NewVerificationDocument = typeof verificationDocuments.$inferInsert;
export type SecurityLog = typeof securityLogs.$inferSelect;
export type NewSecurityLog = typeof securityLogs.$inferInsert;
export type TrustedDevice = typeof trustedDevices.$inferSelect;
export type NewTrustedDevice = typeof trustedDevices.$inferInsert;
export type TollGate = typeof tollGates.$inferSelect;
export type NewTollGate = typeof tollGates.$inferInsert;
export type SuspiciousActivity = typeof suspiciousActivities.$inferSelect;
export type NewSuspiciousActivity = typeof suspiciousActivities.$inferInsert;
export type AdminUser = typeof adminUsers.$inferSelect;
export type NewAdminUser = typeof adminUsers.$inferInsert;
export type ComplianceDocument = typeof complianceDocuments.$inferSelect;
export type NewComplianceDocument = typeof complianceDocuments.$inferInsert;
export type ContentReport = typeof contentReports.$inferSelect;
export type NewContentReport = typeof contentReports.$inferInsert;
export type ModerationResponse = typeof moderationResponses.$inferSelect;
export type NewModerationResponse = typeof moderationResponses.$inferInsert;
export type UserLocation = typeof userLocations.$inferSelect;
export type NewUserLocation = typeof userLocations.$inferInsert;
export type PaymentMethod = typeof paymentMethods.$inferSelect;
export type NewPaymentMethod = typeof paymentMethods.$inferInsert;
export type AdminPaymentAction = typeof adminPaymentActions.$inferSelect;
export type NewAdminPaymentAction = typeof adminPaymentActions.$inferInsert;
export type AccountFlag = typeof accountFlags.$inferSelect;
export type NewAccountFlag = typeof accountFlags.$inferInsert;
export type Conversation = typeof conversations.$inferSelect;
export type NewConversation = typeof conversations.$inferInsert;
export type DriverVerification = typeof driverVerifications.$inferSelect;
export type NewDriverVerification = typeof driverVerifications.$inferInsert;
export type AuditLog = typeof auditLogs.$inferSelect;
export type NewAuditLog = typeof auditLogs.$inferInsert;
export type Tracking = typeof tracking.$inferSelect;
export type NewTracking = typeof tracking.$inferInsert;
export type Escrow = typeof escrows.$inferSelect;
export type NewEscrow = typeof escrows.$inferInsert;
export type DeliveryConfirmation = typeof deliveryConfirmations.$inferSelect;
export type NewDeliveryConfirmation = typeof deliveryConfirmations.$inferInsert;
